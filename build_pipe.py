import argparse
import difflib
import os
import re
import sys
from pathlib import Path

FILES_TO_BUNDLE = [
    "src/utils/logger.py",
    "src/constants.py",
    "src/state.py",
    "src/utils/text.py",
    "src/utils/embeddings.py",
    "src/search.py",
    "src/content.py",
    "src/pipe_shared.py",
    "src/pipe_state.py",
    "src/pipe_research_state.py",
    "src/pipe_text.py",
    "src/pipe_compression.py",
    "src/pipe_semantics.py",
    "src/pipe_fetching.py",
    "src/pipe_citations.py",
    "src/pipe_searching.py",
    "src/pipe_llm.py",
    "src/pipe_interactive.py",
    "src/pipe_synthesis.py",
    "src/pipe_entry.py",
    "src/pipe_impl.py",
]

DEFAULT_OUTPUT_FILE = "pipe.py"

_SRC_IMPORT_RE = re.compile(r"^\s*(?:from|import)\s+src(?:\.|\s|$)")
_FUTURE_IMPORT_RE = re.compile(r"^\s*from\s+__future__\s+import\s+")


def _read_text(path: str) -> str:
    return Path(path).read_text(encoding="utf-8")


def _strip_src_imports(text: str) -> str:
    cleaned_lines: list[str] = []
    skip_paren_depth = 0

    for raw_line in text.splitlines():
        if skip_paren_depth > 0:
            skip_paren_depth += raw_line.count("(") - raw_line.count(")")
            if skip_paren_depth <= 0:
                skip_paren_depth = 0
            continue

        if _FUTURE_IMPORT_RE.match(raw_line):
            continue

        if _SRC_IMPORT_RE.match(raw_line):
            # Handle multiline imports like:
            #   from src.x import (
            #       a,
            #   )
            paren_delta = raw_line.count("(") - raw_line.count(")")
            if paren_delta > 0:
                skip_paren_depth = paren_delta
            continue

        cleaned_lines.append(raw_line)

    return "\n".join(cleaned_lines).rstrip() + "\n"


def bundle_text(
    file_paths: list[str],
    *,
    allow_missing: bool = False,
) -> str:
    missing = [p for p in file_paths if not os.path.exists(p)]
    if missing and not allow_missing:
        raise FileNotFoundError(
            "Missing bundle inputs:\n" + "\n".join(f"- {p}" for p in missing)
        )

    parts: list[str] = []
    parts.append("# AUTOGENERATED by build_pipe.py; DO NOT EDIT.")
    parts.append("# Source files:")
    parts.extend([f"# - {p}" for p in file_paths])
    parts.append("")
    parts.append("from __future__ import annotations")
    parts.append("")

    for file_path in file_paths:
        if not os.path.exists(file_path):
            continue
        raw = _read_text(file_path)
        cleaned = _strip_src_imports(raw)
        parts.append(f"# --- Start of {file_path} ---")
        parts.append(cleaned.rstrip("\n"))
        parts.append(f"# --- End of {file_path} ---")
        parts.append("")

    return "\n".join(parts).rstrip() + "\n"


def _write_text(path: str, content: str) -> None:
    Path(path).write_text(content, encoding="utf-8")


def _diff(a: str, b: str, *, fromfile: str, tofile: str) -> str:
    return "".join(
        difflib.unified_diff(
            a.splitlines(keepends=True),
            b.splitlines(keepends=True),
            fromfile=fromfile,
            tofile=tofile,
        )
    )


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(
        description="Bundle src/ modules into a single OpenWebUI-compatible pipe.py"
    )
    parser.add_argument(
        "-o",
        "--output",
        default=DEFAULT_OUTPUT_FILE,
        help=f"Output file path (default: {DEFAULT_OUTPUT_FILE})",
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Do not write output; fail if output differs from generated bundle",
    )
    parser.add_argument(
        "--diff",
        action="store_true",
        help="With --check, print unified diff when output differs",
    )
    parser.add_argument(
        "--allow-missing",
        action="store_true",
        help="Skip missing input files instead of failing",
    )
    args = parser.parse_args(argv)

    generated = bundle_text(FILES_TO_BUNDLE, allow_missing=args.allow_missing)

    if args.check:
        output_path = args.output
        if not os.path.exists(output_path):
            sys.stderr.write(
                f"{output_path} does not exist; run: python3 build_pipe.py -o {output_path}\n"
            )
            return 1
        current = _read_text(output_path)
        if current != generated:
            sys.stderr.write(f"{output_path} is out of date.\n")
            if args.diff:
                sys.stderr.write(
                    _diff(current, generated, fromfile=output_path, tofile="generated")
                )
            return 1
        return 0

    _write_text(args.output, generated)
    print(f"Successfully bundled into {args.output}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
